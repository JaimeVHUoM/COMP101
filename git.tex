
\section{Git and GitLab}

During your time at school or college, you'll no doubt have written essays and assignments that took more than one session to complete, and you've probably experienced some annoyances associated with transferring the files containing your work between different machines. Perhaps you started writing on a PC at college, took it home to work on a bit more, and finished it off in a library or on a laptop in a cafe. You may have moved the file around using a cloud-based system like Dropbox or Google Drive, or perhaps you transported it around with you on a USB drive. In any case, it's more than likely that at some point you'll have got yourself muddled up working out which version of the file is the latest, or needed to undo some changes and had to remember which version of the file to go back to. If you've been unlucky, you may have lost important changes along the way, or got to a stage where it feels impossible to undo some unwanted change that you've made because it affects so many different parts of your work that you don't know how to remove their effect without messing up your whole document. If you've ever tried to work collaboratively on a project with someone else, you'll probably have found it quite hard to co-ordinate changes so that things you do don't trample on things that someone else is working on at the same time. 

These are all well-known problems associated with doing any kind of writing or project work that takes more than a few minutes to complete, where you're using multiple machines and/or are working with other people; and as you work on more complex projects over longer periods of time and with bigger groups, the bad news is that these problems all get worse. You can, to a certain extent improve the situation by sticking to certain conventions, such as making regular backups of your work with particular kinds of filenames, or promising always to email your collaborators before you make a change to anything and emailing them again when you've finished your changes. But these informal `social agreements' easily collapse when you are tired or stressed, leaving you with a mess to clear up. The good news is that there are industry-standard ways of dealing with these problems, and in the last part of today's session we're going to introduce you to the basics of version control using Git and Gitlab. 

Git and gitlab are tools to help you manage change. Whether you're working on something on your own or as part of a team, a little effort spent learning how to use these tools now will save you significant amounts of pain and hassle later on. 

Git is a version control system, and is one of the most popular of the thirty or so different systems in use today. It is arguably one of the most powerful and flexible version control systems available, and this does mean that your first contact with it can be a little daunting; but if you follow our instructions carefully and don't get too hung up on the bits that we're having to skim over to keep things simple, you'll soon get the hang of things. 

GitLab is a web-based interface to git which makes it easy (at least, easier) to set up projects and teams for collaborative work. Mastering any version control system takes a long time, and you may find in the early days that using git feels as though its more hassle than its worth --- but version control is a crucial skill for any modern computer scientist, and its important that you get used to the principles right from the start of your degree. And trust us, at some point it is going to save you an enormous amount of trouble!

In combination git and gitlab provide mechanisms for:
\begin{itemize}
\item safely moving files from one machine to another without losing changes in the process. You'll probably find this useful early on, and essential when you start working on your group project,
\item tracking changes that you've made so that you can safely undo things that you later decide you don't want, and
\item keeping things under control when you're working with others on a shared piece of work.
\end{itemize}

Today we're going to keep things as simple as possible, and are just going to use git and gitlab for the first of these things; moving files between machines. 

Before we can start to use the tools properly, there's some housekeeping that we need to do. 

\subsection{Configuring git}

Git has already been installed on the school's system, but you'll need to set up some things that are specific to your user before it will work sensibly. 

Fire up a terminal, and enter the following commands:

\begin{ttoutenv}
git config --global user.name "[YOUR NAME GOES HERE]"
git config --global user.email "[YOUR UNIVERSITY EMAIL GOES HERE]" 
\end{ttoutenv}

Hopefully the purpose of these commands is self-explanatory; you're just telling git who you are and how to contact you by email if it needs to. The next bit of configuration is a bit more mysterious, and explaining what it does would require more explanation than is sensible here, so for now just treat these next instruction as a thing you have to do:

\begin{ttoutenv}
git config --global push.default simple
git config --global branch.autosetuprebase always 
\end{ttoutenv}

The next few instructions are optional, but make the output of git nicer to read, so we recommend you also do:

\begin{ttoutenv}
git config --global color.ui true
git config --global color.status auto
git config --global color.branch auto 
\end{ttoutenv}

and finally you should configure git to use whatever editor you've decided is your favourite at the moment, for example:

\begin{ttoutenv}
git config --global core.editor nano 
\end{ttoutenv}

Check that you've typed these correctly by using the command \ttout{git config --list}. You should see all the things you've entered just now, along with a few other bits of default configuration that were set automatically for you by the system (you can safely ignore these for now).


\subsection{Setting up gitlab}

Next we're going to set up gitlab. Point your browser at the School's installation of gitlab at:
\\
\url{http://gitlab.cs.man.ac.uk}
\\
and log in with your University credentials. You should see Gitlab's `dashboard' page and not much else (see Figure \ref{figure:gitlab-first-login}). Go to the `My Profile' section of gitlab using the icon at the top right of the page, and fill in any details about you that you're comfortable sharing with other students and staff within the school. At a minimum you should make sure that your Name and Email are set correctly; the other fields are optional (if you'd like your gitlab account to have an avatar image, you'll need to sign up for a Gravatar account, which is a bit of a nuisance but not that hard). 

\begin{figure}
\centerline{\includegraphics[width=15cm]{images/gitlab-first-login}}
\caption{First login to Gitlab. \protect\circled{1} The Gitlab logo (a sort of raccoon thing) will bring you back to the dashboard; useful if you get lost in gitlab's structure; \protect\circled{2} the user-profile allows you to add more information about yourself, and optionally connect up to Gravatar to give you a user icon; and \protect\circled{3} various ways to create a new project.}\label{figure:gitlab-first-login}
\end{figure}

Select thew `New Project' button from the icons at the top right. Enter \ttout{aboutme} as the project name, and hit `Create project'. You'll see a page similar to Figure \ref{figure:gitlab-new-project}. Notice that the `Git global setup' section contains the commands that you used in the previous section to set up your git configuration; so you don't need to do that again. There are also two other sections of code on how to `create repository' or use `Existing Git Repo?'. Ignore both of these for now and instead follow the instructions here (notice at the top of the gitlab page a warning that `You won't be able to pull or push project code via SSH until you add an SSH key to your profile' -- we need to fix that first). Click on the `add an SSH key' link (marked with \protect\circled{1} on Figure \ref{figure:gitlab-new-project}), which will take you to the SSH key upload page which looks something like Figure \ref{figure:gitlab-ssh}.

\begin{figure}
\centerline{\includegraphics[width=15cm]{images/gitlab-new-project}}
\caption{Creating a new project in Gitlab. \protect\circled{1} You will need to use the  `add an SSH key' link to upload your public key before you can communicate between git and gitlab, and the URL given in \protect\circled{2} can be used from the command line to clone and push this project.}\label{figure:gitlab-new-project}
\end{figure}

\begin{figure}
\centerline{\includegraphics[width=13cm]{images/gitlab-ssh}}
\caption{Adding a SSH key to Gitlab. Once you have used \ttout{ssh-keygen} to create the key, paste the text into the `Key' box; if your key is valid then the title will be filled in for you.}\label{figure:gitlab-ssh}
\end{figure}


You'll now need to set up a means of securely identifying yourself to Gitlab from whichever machine you're using at the time; this is done by creating what's called a `ssh key'. In a terminal, type

\begin{ttoutenv}
ssh-keygen -t rsa -C "[YOUR UNIVERSITY EMAIL]"
\end{ttoutenv}

to create yourself a SSH key. When prompted `Enter file in which to save the key' just press return to accept the default, and the same for `Enter passphrase' twice.  For now don't worry too much about exactly what a SSH key is -- we'll just treat it as a way of identifying yourself to the Gitlab server. 

Look in a directory called \ttout{~/.ssh} and you'll find two new files have been created called \ttout{id\_rsa} and \ttout{id\_rsa.pub}. The first of these is the \textit{private} part of the SSH key that's just been generated for you, and you should keep this secret. The second of these is the \textit{public} part of the key, and this is the bit you need to hand over to gitlab for it to be able to identify you. Use the command

\begin{ttoutenv}
$ less ~/.ssh/id_rsa.pub
\end{ttoutenv}
% $
to display the contents of your public key. You should see something like:

\begin{ttoutenv}
  
  ssh-rsa  AAAAB3NzaC1yc2EAAAADAQABAAABAQDTfAF0KxG94oUJLUER5Ci5HaoEtdi8KI0S+
  iro3EvVkQebW2V3nCaCLAHLmgmINm/NFW5bvbUq7bu2CxFlVBEQqa1idZBLceXKRi1SFtG+
  EzFENyzZBsIDU0IhfQX4qyxgqe0A3ortyAwm2/+0neu74RT0YK3gQI+wyxsFFoCzbahiDJisK
  /vKmqvwowb/Rrl3OZpX9ZO3QA9lgILLVy3J4VpAhR+05MyuM/Bzh/pYk5NIQivedUEduIJXLOetj/
  UnxlH9WbEPEIiDPvzrkb3xI98rLRSlh2hH89nc1SUfVEhY62RQWN7sbXPu+fFck7Dom9wE/
  YAG66Dbl30OsmFh mister.noodle@manchester.ac.uk

\end{ttoutenv}


which starts with \ttout{ssh-rsa}, ends with your email address, and has a load of apparently random characters in between. Select this text (making sure you don't accidentally select any extra newlines or spaces either side of it) and 
Copy and Paste the whole of the SSH key into the `Key' box on the gitlab page. If you've done this correctly, gitlab will spot the email from your key and use this as the `Title' field, in which case just press the Save button. Gitlab will complain if it's not a valid key or has extra spaces or newlines at this point; if you're stuck here grab a demonstrator to help you. 

Once you've uploaded your public key to gitlab, you're ready to put your first bit of content into the `aboutme' project that you've just created. 

Click on the gitlab logo at the top left of the gitlab page to get back to the dashboard, and select the `aboutme' project that you created a moment ago.  Back at your terminal command prompt change to the directory called `aboutme' that you copied over from the Pi at the end of the last session; this should contain at least three files if everything has gone to plan: a bit of HTML about you, a photograph of your, and whatever image you drew using Inkscape (if for whatever reason you didn't get as far as that part in the last session, there's a default set of files you can use; copy them from \ttout{/opt/info/courses/COMP101/aboutme} into a directory called \ttout{aboutme} in your home directory and press on.)

\begin{note}
 Need to set this up in /opt/info
\end{note}

In your \ttout{aboutme} directory, type the following command:

\begin{ttoutenv}
$ git init
\end{ttoutenv}

which tells git that you're about to put this directory under its control; this is known as initialising a repository. Git will respond by telling you that it has `Initialized empty Git repository in ' followed by the full pathname of your \fname{aboutme} directory. 

Type
\begin{ttoutenv}
$ git status
\end{ttoutenv}

and you'll see a message from git that, amongst other things tells you that there are `untracked files' (these should appear in red). 

Now we need to tell git which files we want it to track for us. For each of the three files in that directory run a command along the lines of 

\begin{ttoutenv}
$ git add [FILENAME]
\end{ttoutenv}

% $

replacing [FILENAME] with each of the three file names in turn. Once you've done this, run \ttout{git status} again,, and this time you should see that there are a list of `Change to be committed' and all the files that you'd just added should appear in green. 

Now git knows which of the files in this directory you want to track (which in this case is all of them), we want to do our first `commit', which tells git that we've made a set of changes that we want to keep together: in this case the `changes' are to create the files in the first place; later one we'll go through a similar pattern of \ttout{git add} and {git commit} whenever we've done a set of changes that we think we are happy with. 

The \ttout{-m "Initial Commit"} part of the commit line gives git a label to associate with this particular commit, and it's traditional to put the message `Initial Commit' the first time you tell git about a new set of files. In future you'll be putting text here that summarises in human-readable form what changes you've made in this commit, but more on that later.

\begin{ttoutenv}
$ git commit -m "Initial Commit"
\end{ttoutenv}

Don't worry about what git's response means here, that will become clear as you learn more. Type \ttout{git status} once more and if everything has gone to plan you should see the response

\begin{ttoutenv}
# On branch master
nothing to commit (working directory clean)
\end{ttoutenv}

If you get a different message here, then something has gone wrong in one of the previous steps; don't worry, just call a demonstrator to help out. 

So to recap: in gitlab we've created a project called `aboutme' ready to accept some files, and in your home directory we've created a new repository (which happens to have the same name). The next step is to make an association between the repository in your home filestore, and the project on the gitlab server. 

Look back at the aboutme project's page on gitlab, and you'll see a box with a pair of controls labelled `SSH' and `HTTPS' followed by a fairly long URL (labelled with \protect\circled{2} in Figure \ref{figure:gitlab-new-project}) that is something similar to:

\begin{ttoutenv}
ssh://gitlab@gitlab.cs.man.ac.uk:22222/mister.noodle/aboutme.git
\end{ttoutenv}

Then enter the following command, copy-and-pasting the URL from the web page into the appropriate bit of commandline:

\begin{ttoutenv}
$ git remote add origin [GITLAB-URL-GOES-HERE]
\end{ttoutenv}

And finally to send this first version of the repository over to the gitlab server, enter

\begin{ttoutenv}
$ git push -u origin master
\end{ttoutenv}

which should respond with some variation of 

\begin{ttoutenv}
Counting objects: 3, done.
Writing objects: 100% (3/3), 216 bytes, done.
Total 3 (delta 0), reused 0 (delta 0)
To ssh://gitlab@gitlab.cs.man.ac.uk:22222/mister.noodle/aboutme.git
 * [new branch]      master -> master
Branch master set up to track remote branch master from origin by rebasing.
\end{ttoutenv}

To check that everything worked properly, run the command \ttout{git pull} (note that you won't need to put the \ttout{-u origin master} bits after git pull from now on), and you should get the response:

\begin{ttoutenv}
Everything up-to-date
\end{ttoutenv}

Again, if something has gone wrong and you can't see what, grab a demonstrator. 

Go back to the gitlab page in your browser, and select the dashboard by clicking on the gitlab logo at the top left. On the right, you should see your `aboutme' project; you should see a history of what's happened to the project so far which will include you joining the project, and `pushed a new branch'. Select the `Files' page from the menu near the top of the page, and you should see a list of the three files that you've added so far. 

To recap; you've now created your first local repository (the directory in your filestore called \fname{aboutme}), added and committed your first `changes' (which in this case meant telling git about the existence of the files you want to track in the first instance), and synchronised these files with a remote repository hosted by the School's gitlab server. That may have all seemed like rather hard work, but now you're set up to use the respository for real, and things get a bit easier from here on. 

\subsection{Cloning a repository}

Imagine now that after a particularly hard day's work, you've accidentally deleted your \fname{aboutme} directory. In fact, let's just do that now. Change to your home directory, and type

\begin{ttoutenv}
$ rm -rf aboutme
\end{ttoutenv}

which will recursively delete the \fname{aboutme} directory and all its contents without prompting you for anything. Check that the directory has gone using \ttout{ls}. And now let's fetch it back from our remote gitlab repository (which is nicely backed up for you by the School's IT Services, so you can be safe that nothing bad will happen to it). Type

Find the ssh URL for the project in gitlab, and paste the URL into the \ttout{git clone} command:

\begin{ttoutenv}
$ git clone [PROJECT-URL-GOES-HERE]
\end{ttoutenv}

%$
You should see a response that starts with `Cloning into' followed by some other lines of stuff, and your `aboutme' repository should re-appear, complete with all its contents.

Change into the \fname{aboutme} directory, and issue \ttout{git status}, which should reassuringly tell you that there is `nothing to commit (working directory clean)' (which means `you've not made any changes since the last time you touched this repository'). 

Now edit the HTML file to make some small change (it can be anything you'd recognise as a change, doesn't matter what), and once more type \ttout{git status} to see what git things has happened.

Git should tell you that your HTML file is now `modified'. You've now got two options:
\begin{itemize}
\item Let's say you want to throw away the change you've just made  (imagine it was a much more complex edit
  than the one you've just  made, and you're not happy with it). To do this you can run
  \ttout{git checkout -- [FILENAME]} to revert the file back to the
  last version you committed.
\item Alternatively, if you want to keep the change you've made, you can run \ttout{git add [FILENAME]}
  followed by \ttout{git commit [FILENAME] -m "[A DESCRIPTION OF WHAT YOU CHANGED]"} to commit the file to your local repository. 
\end{itemize}

When you want to preserve your commit on the server (for example, because you've finished for the day and want to pick up the files when you get home, or because someone else in your team needs to see your changes, or because you've finished a nice complete self-contained bit of work), you can then syncrhonise your local repository with the project hosted on gitlab. To do this, you just need to issue 

\begin{ttoutenv}
$ git push
\end{ttoutenv}
% $

and any commits that you've made will get pushed to the gitlab server. 

Experiment now by making a few more changes to the contents of your aboutme directory; add an extra file or two, and modify their content. Use \ttout{git status} regularly to make sure that git reflects what you're doing. Keep in mind the following principles:

\begin{itemize}
\item When you've modified one or more files and want git to know about these changes, use \ttout{git add} to tell git to track the changes to those files.

\item You don't need to use \ttout{commit} after every \ttout{add};
  you can safely bundle up a set of \ttout{add}s in a single commit,
  (when you start working on more complex projects you'll find that is often the case). A    commit should represent a coherent set
  of changes to your work that you are recording for a particular
  reason. You should summarise this reason in the log entry message
  that follows the \ttout{-m} switch on the \ttout{git commit} line, so that
  later on you can see what the different commits were for.

\item When you have finished a particular job, or need to move to another machine, use \ttout{git push} to synchronise the changes you've made to your local repository with the gitlab server; then these changes can be picked up from elsewhere or (later on when you're doing project work) by other people in your team. 
\end{itemize}

After you've played around with \ttout{add}, \ttout{commit} and \ttout{push} a few times, try using the \ttout{git log} command to see the history of what you've done. You should also be able to see this history in gitlab as well --- but we'll leave you to explore the gitlab interface to find out how to do that. 

\subsection{Using git/gitlab to transfer files between machines}

Clone and pull. 

\subsection{Using git to publish content to a webserver}

By now you should have a basic idea of how you can use git to track modifications to files, and how gitlab can help you move files between machines (and when the time comes, an inkling of how it can be used to share content with other members of your project). To finish off this session we're going to show you how to use git and gitlab to manage changes to a website.

In your previous experiments with the simple Python webserver and Apache on your Pi, you've been creating and manipulating files in a directory that is directly visible to the web server. So every time you change and save a file, that change becomes immediately visible to the web server, and therefore to anybody viewing the web page. This was great as a way of showing you what a webserver is really doing behind the scenes, but it's not a good example of how `real world websites' are managed. A real website typically consists of lots of interlinked pages, and changing just one file at a time would mean that during the period you're making edits the content of the site could become inconsistent. Often what you really want to do is to make a whole set of changes to different files, and then only when you're happy that you've made all the changes you need, to make the updated site visible to users. Of course you could do this by taking a copy of the website's files, editing them `offline' somewhere, and then copying them back manually in to the right place on the web server's filestore---but hopefully by now you can see how git/gitlab can help out here.
